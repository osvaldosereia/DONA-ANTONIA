<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Conversor e Compressor AVIF Local de Alta Performance.">
    <title>SISTEMAS | AVIF Converter Pro</title>
    <style>
        /* --- SISTEMAS DESIGN SYSTEM (Minimal & Performant) --- */
        :root {
            --primary: #4f46e5;
            --primary-hover: #4338ca;
            --bg: #f9fafb;
            --surface: #ffffff;
            --text-main: #111827;
            --text-muted: #6b7280;
            --border: #e5e7eb;
            --radius: 12px;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --focus-ring: 0 0 0 3px rgba(79, 70, 229, 0.3);
            --safe-green: #059669;
            --warn-red: #dc2626;
        }

        /* Reset & Base */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            line-height: 1.5;
            padding: 1.5rem;
            min-height: 100vh;
        }

        /* Layout */
        main {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        /* Typography */
        h1 { font-size: 1.875rem; font-weight: 800; letter-spacing: -0.025em; color: var(--primary); text-align: center; }
        h2 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; }
        .subtitle { text-align: center; color: var(--text-muted); font-size: 0.95rem; }
        .highlight { color: var(--warn-red); font-weight: 700; }

        /* Components */
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
        }

        /* Drop Zone */
        .drop-zone {
            border: 2px dashed var(--border);
            text-align: center;
            padding: 3rem 1.5rem;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
        }
        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--primary);
            background-color: #eef2ff;
        }
        .drop-zone input[type="file"] {
            position: absolute; width: 100%; height: 100%; top: 0; left: 0; opacity: 0; cursor: pointer;
        }
        .btn-upload {
            background-color: var(--primary);
            color: white;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            display: inline-block;
            margin-bottom: 0.5rem;
            pointer-events: none; /* Let the input handle clicks */
        }

        /* Options Checkbox */
        .options-bar {
            margin-top: 1.5rem;
            display: flex;
            justify-content: center;
            gap: 1.5rem;
        }
        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-main);
            cursor: pointer;
            user-select: none;
            z-index: 10; /* Ensure it's clickable above the file input overlay if needed */
            position: relative;
        }
        .checkbox-wrapper input {
            accent-color: var(--primary);
            width: 1.1rem;
            height: 1.1rem;
            cursor: pointer;
        }

        /* Result List */
        .results-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border); padding-bottom: 0.75rem; margin-bottom: 1rem; }
        .image-list { display: grid; gap: 1rem; }
        
        .result-item {
            display: grid;
            grid-template-columns: 80px 1fr auto;
            gap: 1rem;
            align-items: center;
            padding: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            animation: fadeIn 0.3s ease-out;
        }

        .preview-thumb {
            width: 80px; height: 80px;
            object-fit: cover;
            border-radius: 8px;
            background: #f3f4f6;
        }

        .meta-group { display: flex; flex-direction: column; gap: 0.25rem; min-width: 0; }
        .meta-row { display: flex; gap: 1rem; font-size: 0.85rem; color: var(--text-muted); align-items: center; }
        
        input[type="text"] {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.9rem;
            transition: border-color 0.2s;
        }
        input[type="text"]:focus { outline: none; border-color: var(--primary); box-shadow: var(--focus-ring); }

        /* Actions */
        .actions { display: flex; gap: 0.5rem; }
        .btn {
            display: inline-flex; align-items: center; justify-content: center;
            padding: 0.6rem 1rem;
            font-size: 0.9rem;
            font-weight: 500;
            border-radius: 8px;
            text-decoration: none;
            transition: background 0.2s;
            border: none;
            cursor: pointer;
            gap: 0.5rem;
        }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-hover); }
        .btn-secondary { background: white; border: 1px solid var(--border); color: var(--text-main); }
        .btn-secondary:hover { background: #f3f4f6; }
        
        .badge {
            font-size: 0.7rem; font-weight: 700; padding: 2px 6px; border-radius: 4px; text-transform: uppercase;
        }
        .bg-green { background: #d1fae5; color: #065f46; }
        .bg-yellow { background: #fef3c7; color: #92400e; }
        .text-green { color: var(--safe-green); font-weight: 700; }
        .text-red { color: var(--warn-red); font-weight: 700; }

        /* Dialog / Modal */
        dialog {
            margin: auto;
            padding: 0;
            border: none;
            border-radius: var(--radius);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            max-width: 95vw;
            max-height: 95vh;
            background: var(--surface);
            overflow: hidden;
        }
        dialog::backdrop { background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(2px); }
        
        .modal-header { padding: 1rem; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        .modal-body { padding: 1.5rem; display: flex; flex-direction: column; align-items: center; gap: 1.5rem; }
        .modal-footer { padding: 1rem; border-top: 1px solid var(--border); display: flex; justify-content: flex-end; gap: 0.75rem; background: var(--bg); }

        /* Editor Area */
        .editor-container {
            position: relative;
            width: 300px;
            height: 300px;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 0 0 2px var(--border);
            background: #e5e5e5;
            cursor: grab;
            touch-action: none; /* Prevent scroll on touch */
        }
        .editor-container:active { cursor: grabbing; }
        
        /* O Canvas de edição é renderizado via JS */
        #editor-canvas {
            display: block;
        }

        .controls { width: 100%; max-width: 300px; display: flex; flex-direction: column; gap: 0.5rem; }
        input[type="range"] { width: 100%; accent-color: var(--primary); }

        /* Responsive */
        @media (max-width: 640px) {
            .result-item { grid-template-columns: 1fr; text-align: center; }
            .preview-thumb { width: 100%; height: 200px; margin-bottom: 0.5rem; }
            .meta-row { justify-content: center; }
            .actions { flex-direction: column; }
            .btn { width: 100%; }
            .options-bar { flex-direction: column; align-items: center; gap: 0.5rem; }
        }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        /* SVGs */
        .icon { width: 20px; height: 20px; stroke: currentColor; stroke-width: 2; fill: none; stroke-linecap: round; stroke-linejoin: round; }
    </style>
</head>
<body>

    <main>
        <header>
            <h1>AVIF Pro Converter</h1>
            <p class="subtitle">Smart Crop • 400x400px • <span class="highlight">Garantia de 30KB</span></p>
        </header>

        <!-- Drop Zone -->
        <div class="card drop-zone" id="drop-zone">
            <!-- Icon Cloud -->
            <svg class="icon" style="width: 48px; height: 48px; color: var(--primary); margin-bottom: 1rem;" viewBox="0 0 24 24"><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"></path><path d="M12 12v9"></path><path d="m16 16-4-4-4 4"></path></svg>
            
            <div>
                <span class="btn-upload">Selecionar Imagens</span>
                <input type="file" id="file-input" accept="image/*" multiple>
            </div>
            <p style="margin-top: 1rem; color: var(--text-muted); font-size: 0.875rem;">Ou arraste e solte seus arquivos</p>

            <!-- Logo Option -->
            <div class="options-bar">
                <label class="checkbox-wrapper" title="Adiciona a logo no canto inferior direito">
                    <input type="checkbox" id="chk-use-logo">
                    <span>Incluir Logo (Dona Antônia)</span>
                </label>
            </div>
        </div>

        <!-- Results -->
        <div id="results-area" class="card" style="display: none;">
            <div class="results-header">
                <h2>Imagens Otimizadas</h2>
                <span id="status-counter" style="font-size: 0.875rem; color: var(--text-muted);"></span>
            </div>
            <div id="image-list" class="image-list">
                <!-- Javascript injects items here -->
            </div>
        </div>
    </main>

    <!-- Modal de Edição (Nativo <dialog>) -->
    <dialog id="edit-modal">
        <div class="modal-header">
            <h3>Ajustar Recorte</h3>
            <button id="close-modal" class="btn-secondary" style="padding: 4px 8px; border:none; background:transparent;">
                <svg class="icon" viewBox="0 0 24 24"><path d="M18 6 6 18"></path><path d="m6 6 12 12"></path></svg>
            </button>
        </div>
        <div class="modal-body">
            <!-- Viewport Quadrada 300x300 para edição -->
            <canvas id="editor-canvas" width="300" height="300" class="editor-container"></canvas>
            
            <div class="controls">
                <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:var(--text-muted);">
                    <span>Zoom</span>
                    <span id="zoom-value">100%</span>
                </div>
                <input type="range" id="zoom-slider" min="1" max="4" step="0.05" value="1">
                
                <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border);">
                    <label class="checkbox-wrapper" style="justify-content: center;">
                        <input type="checkbox" id="chk-use-logo-modal">
                        <small>Incluir Logo nesta imagem</small>
                    </label>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-primary" id="confirm-crop">
                <svg class="icon" viewBox="0 0 24 24"><path d="M5 13l4 4L19 7"></path></svg>
                Aplicar e Comprimir
            </button>
        </div>
    </dialog>

    <script>
        // --- CONFIGURAÇÃO ---
        const CONFIG = {
            targetWidth: 400,
            targetHeight: 400,
            maxSizeBytes: 30 * 1024, // 30KB
            formats: ['image/avif', 'image/webp', 'image/jpeg'],
            logoPath: 'img/logo-super-cesta-basica-dona-antonia-cuiaba-varzea-grande.avif'
        };

        // --- ESTADO GLOBAL DO EDITOR ---
        const editorState = {
            activeFile: null,      // File original
            activeCardId: null,    // ID do card sendo editado
            imgBitmap: null,       // ImageBitmap para performance
            scale: 1,
            offsetX: 0,
            offsetY: 0,
            minScale: 1
        };

        // Cache para a logo
        let logoImage = null;

        // --- DOM ELEMENTS ---
        const fileInput = document.getElementById('file-input');
        const dropZone = document.getElementById('drop-zone');
        const resultsArea = document.getElementById('results-area');
        const imageList = document.getElementById('image-list');
        const statusCounter = document.getElementById('status-counter');
        const chkUseLogo = document.getElementById('chk-use-logo');
        
        const modal = document.getElementById('edit-modal');
        const editorCanvas = document.getElementById('editor-canvas');
        const ctxEditor = editorCanvas.getContext('2d');
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');
        const btnConfirmCrop = document.getElementById('confirm-crop');
        const btnCloseModal = document.getElementById('close-modal');
        const chkUseLogoModal = document.getElementById('chk-use-logo-modal');

        // --- EVENT LISTENERS GERAIS ---
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => { dropZone.classList.remove('dragover'); });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        
        // Sincronizar checkbox do modal com o principal
        chkUseLogo.addEventListener('change', () => {
            chkUseLogoModal.checked = chkUseLogo.checked;
        });

        // --- LOGO LOADING ---
        async function loadLogo() {
            if (logoImage) return logoImage;
            
            return new Promise((resolve) => {
                const img = new Image();
                img.src = CONFIG.logoPath;
                img.crossOrigin = "Anonymous";
                img.onload = () => {
                    logoImage = img;
                    resolve(img);
                };
                img.onerror = () => {
                    console.warn("Logo não encontrada em: " + CONFIG.logoPath);
                    resolve(null);
                }
            });
        }

        async function drawLogoOnCanvas(ctx, canvasW, canvasH) {
            const logo = await loadLogo();
            if (!logo) return;

            // Configurações de tamanho e posição da logo
            // Vamos definir a logo com largura de aprox 25% do canvas (100px em 400px)
            const targetLogoWidth = 100; 
            const scaleFactor = targetLogoWidth / logo.width;
            const logoW = logo.width * scaleFactor;
            const logoH = logo.height * scaleFactor;

            // Margem da borda (quase encostando)
            const padding = 12;

            const x = canvasW - logoW - padding;
            const y = canvasH - logoH - padding;

            // Sombra leve para garantir contraste se a imagem for branca
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;

            ctx.drawImage(logo, x, y, logoW, logoH);
            
            // Reset shadow
            ctx.shadowColor = "transparent";
        }

        // --- CORE: FILE PROCESSING ---
        async function handleFiles(files) {
            if (files.length > 0) resultsArea.style.display = 'block';
            
            // Se o user marcou logo, garante que está carregada
            if (chkUseLogo.checked) await loadLogo();

            const filesArray = Array.from(files);
            let processed = 0;
            statusCounter.textContent = `Processando 0/${filesArray.length}...`;

            for (const file of filesArray) {
                if (!file.type.startsWith('image/')) continue;
                
                const cardId = 'card-' + Math.random().toString(36).substr(2, 9);
                // Placeholder inicial na UI
                createResultCard(cardId, file.name, null, true); 

                try {
                    // Processamento Automático Inicial (Smart Center Crop)
                    const bitmap = await createImageBitmap(file);
                    const canvas = document.createElement('canvas');
                    canvas.width = CONFIG.targetWidth;
                    canvas.height = CONFIG.targetHeight;
                    
                    performSmartCrop(canvas, bitmap);

                    // Aplica Logo se selecionado
                    if (chkUseLogo.checked) {
                        const ctx = canvas.getContext('2d');
                        await drawLogoOnCanvas(ctx, canvas.width, canvas.height);
                    }
                    
                    // Compressão
                    const result = await compressImage(canvas, file.name);
                    
                    // Atualiza UI com resultado
                    updateResultCard(cardId, result, file);
                    bitmap.close();
                } catch (err) {
                    console.error("Falha:", err);
                }
                processed++;
                statusCounter.textContent = `Pronto: ${processed}/${filesArray.length}`;
            }
        }

        // --- LÓGICA DE CORTE AUTOMÁTICO (SMART CROP) ---
        function performSmartCrop(canvas, bitmap) {
            const ctx = canvas.getContext('2d');
            // Calcula a proporção "Cover"
            const ratio = Math.max(canvas.width / bitmap.width, canvas.height / bitmap.height);
            const w = bitmap.width * ratio;
            const h = bitmap.height * ratio;
            // Centraliza
            const x = (canvas.width - w) / 2;
            const y = (canvas.height - h) / 2;
            
            ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, x, y, w, h);
        }

        // --- LÓGICA DE COMPRESSÃO (BINARY SEARCH) ---
        async function compressImage(canvas, originalName) {
            // Tenta formatos preferidos
            for (const format of CONFIG.formats) {
                // Checa suporte rápido
                const testBlob = await new Promise(r => canvas.toBlob(r, format, 1));
                if (!testBlob || (format !== 'image/png' && testBlob.type === 'image/png')) continue; // Fallback do browser
                
                // Busca Binária pela qualidade ideal (< 30KB)
                let minQ = 0.0, maxQ = 1.0, bestBlob = null, bestQ = 0;
                
                for(let i=0; i<6; i++) {
                    const midQ = (minQ + maxQ) / 2;
                    const blob = await new Promise(r => canvas.toBlob(r, format, midQ));
                    
                    if (blob.size <= CONFIG.maxSizeBytes) {
                        bestBlob = blob;
                        bestQ = midQ;
                        minQ = midQ; // Tenta melhorar
                    } else {
                        maxQ = midQ; // Diminui qualidade
                    }
                }
                
                // Se falhou em atingir o tamanho, força qualidade mínima
                if (!bestBlob) bestBlob = await new Promise(r => canvas.toBlob(r, format, 0.05));

                return {
                    blob: bestBlob,
                    quality: bestBlob ? (bestQ || 0.05) : 0,
                    format: bestBlob.type
                };
            }
            throw new Error("Nenhum formato suportado.");
        }

        // --- UI RENDERING ---
        function createResultCard(id, name, loading = false) {
            const div = document.createElement('div');
            div.className = 'result-item';
            div.id = id;
            
            if (loading) {
                div.innerHTML = `
                    <div class="preview-thumb" style="background: #e5e7eb; display:flex; align-items:center; justify-content:center;">
                         <svg class="icon animate-spin" viewBox="0 0 24 24"><path d="M21 12a9 9 0 1 1-6.219-8.56"></path></svg>
                    </div>
                    <div><p style="font-weight:600">${name}</p><p class="text-muted">Processando...</p></div>
                `;
            }
            imageList.prepend(div);
            return div;
        }

        function updateResultCard(id, result, originalFile) {
            const card = document.getElementById(id);
            if (!card) return;

            const url = URL.createObjectURL(result.blob);
            const sizeKB = (result.blob.size / 1024).toFixed(2);
            const ext = result.format.split('/')[1] === 'jpeg' ? 'jpg' : result.format.split('/')[1];
            const defaultName = originalFile.name.split('.').slice(0, -1).join('.') + '.' + ext;
            
            // Determina cores baseadas no tamanho
            const isSafe = result.blob.size <= CONFIG.maxSizeBytes;
            const sizeClass = isSafe ? 'text-green' : 'text-red';
            const badgeClass = ext === 'avif' ? 'bg-green' : 'bg-yellow';

            card.innerHTML = `
                <img src="${url}" class="preview-thumb" alt="Preview">
                
                <div class="meta-group">
                    <div style="display:flex; gap:0.5rem; align-items:center; margin-bottom:0.25rem;">
                         <input type="text" value="${defaultName}" class="filename-input">
                         <span class="badge ${badgeClass}">${ext.toUpperCase()}</span>
                    </div>
                    <div class="meta-row">
                        <span><span class="${sizeClass}">${sizeKB} KB</span></span>
                        <span>Q: ${(result.quality * 100).toFixed(0)}%</span>
                    </div>
                </div>

                <div class="actions">
                    <button class="btn btn-secondary btn-edit">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                        Ajustar
                    </button>
                    <a href="${url}" download="${defaultName}" class="btn btn-primary download-link">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                        Baixar
                    </a>
                </div>
            `;

            // Bind Events
            const input = card.querySelector('.filename-input');
            const link = card.querySelector('.download-link');
            const editBtn = card.querySelector('.btn-edit');

            input.addEventListener('input', (e) => {
                if(e.target.value.trim()) link.download = e.target.value;
            });

            // Lógica de Edição "Lazy"
            editBtn.onclick = () => openEditor(originalFile, id);
        }

        // --- EDITOR LOGIC (MODAL) ---

        async function openEditor(file, cardId) {
            editorState.activeFile = file;
            editorState.activeCardId = cardId;
            
            // Sincroniza checkbox do modal com a escolha global
            chkUseLogoModal.checked = chkUseLogo.checked;

            // Carrega imagem para edição
            editorState.imgBitmap = await createImageBitmap(file);
            
            // Setup inicial: Fit Cover na área de 300x300
            const canvasSize = 300;
            const imgW = editorState.imgBitmap.width;
            const imgH = editorState.imgBitmap.height;
            
            // Calcula escala mínima para cobrir o canvas
            const scale = Math.max(canvasSize / imgW, canvasSize / imgH);
            
            editorState.minScale = scale;
            editorState.scale = scale;
            
            // Centraliza
            editorState.offsetX = (canvasSize - imgW * scale) / 2;
            editorState.offsetY = (canvasSize - imgH * scale) / 2;
            
            // Reset Controles
            zoomSlider.min = scale;
            zoomSlider.max = scale * 4;
            zoomSlider.value = scale;
            zoomValue.textContent = "100%";

            renderEditor();
            modal.showModal();
        }

        function renderEditor() {
            // Limpa
            ctxEditor.clearRect(0, 0, 300, 300);
            
            // Preenchimento de fundo para guiar os olhos (cinza escuro fora da img)
            ctxEditor.fillStyle = "#333";
            ctxEditor.fillRect(0,0,300,300);

            if (editorState.imgBitmap) {
                const w = editorState.imgBitmap.width * editorState.scale;
                const h = editorState.imgBitmap.height * editorState.scale;
                ctxEditor.drawImage(editorState.imgBitmap, editorState.offsetX, editorState.offsetY, w, h);
            }
        }

        // Interações do Editor (Pan & Zoom)
        let isDragging = false;
        let lastX = 0, lastY = 0;

        // Mouse Events
        editorCanvas.addEventListener('mousedown', startDrag);
        window.addEventListener('mouseup', stopDrag);
        window.addEventListener('mousemove', drag);
        
        // Touch Events
        editorCanvas.addEventListener('touchstart', (e) => { startDrag(e.touches[0]); e.preventDefault(); }, {passive: false});
        window.addEventListener('touchend', stopDrag);
        window.addEventListener('touchmove', (e) => { drag(e.touches[0]); e.preventDefault(); }, {passive: false});

        function startDrag(e) {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            editorCanvas.style.cursor = 'grabbing';
        }

        function stopDrag() {
            isDragging = false;
            editorCanvas.style.cursor = 'grab';
        }

        function drag(e) {
            if (!isDragging) return;
            
            const deltaX = e.clientX - lastX;
            const deltaY = e.clientY - lastY;
            
            editorState.offsetX += deltaX;
            editorState.offsetY += deltaY;
            
            // Restrições (Não deixar sair borda branca) - Lógica de "Contain"
            const canvasSize = 300;
            const currentW = editorState.imgBitmap.width * editorState.scale;
            const currentH = editorState.imgBitmap.height * editorState.scale;
            
            // Limites: O offset nunca pode ser > 0 (borda esquerda branca) 
            // e nunca menor que canvasSize - currentW (borda direita branca)
            if (editorState.offsetX > 0) editorState.offsetX = 0;
            if (editorState.offsetY > 0) editorState.offsetY = 0;
            if (editorState.offsetX < canvasSize - currentW) editorState.offsetX = canvasSize - currentW;
            if (editorState.offsetY < canvasSize - currentH) editorState.offsetY = canvasSize - currentH;

            lastX = e.clientX;
            lastY = e.clientY;
            
            renderEditor();
        }

        zoomSlider.addEventListener('input', (e) => {
            const newScale = parseFloat(e.target.value);
            const oldScale = editorState.scale;
            
            // Zoom centralizado:
            // O centro atual da viewport (150, 150) deve permanecer sobre o mesmo pixel da imagem
            const canvasCenter = 150;
            
            // Posição do centro relativo à imagem antes do zoom
            const imgX = (canvasCenter - editorState.offsetX) / oldScale;
            const imgY = (canvasCenter - editorState.offsetY) / oldScale;
            
            // Aplica novo zoom
            editorState.scale = newScale;
            
            // Recalcula offset para manter o ponto central
            editorState.offsetX = canvasCenter - (imgX * newScale);
            editorState.offsetY = canvasCenter - (imgY * newScale);
            
            // Reaplica restrições de borda (copiado da função drag para garantir segurança)
            const currentW = editorState.imgBitmap.width * editorState.scale;
            const currentH = editorState.imgBitmap.height * editorState.scale;
            if (editorState.offsetX > 0) editorState.offsetX = 0;
            if (editorState.offsetY > 0) editorState.offsetY = 0;
            if (editorState.offsetX < 300 - currentW) editorState.offsetX = 300 - currentW;
            if (editorState.offsetY < 300 - currentH) editorState.offsetY = 300 - currentH;

            zoomValue.textContent = Math.round((newScale / editorState.minScale) * 100) + "%";
            renderEditor();
        });

        // Botões do Modal
        btnCloseModal.onclick = () => modal.close();
        
        btnConfirmCrop.onclick = async () => {
            // Loading state no botão
            const originalText = btnConfirmCrop.innerHTML;
            btnConfirmCrop.textContent = "Processando...";
            
            try {
                // 1. Criar Canvas final 400x400
                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = CONFIG.targetWidth;
                finalCanvas.height = CONFIG.targetHeight;
                const ctxFinal = finalCanvas.getContext('2d');
                
                // 2. Mapear coordenadas do Editor (300px) para Final (400px)
                // A lógica é: O que está visível no canvas 300x300 deve ir para o 400x400
                // Proporção de escala entre Editor e Final
                const renderRatio = CONFIG.targetWidth / 300; 
                
                const finalScale = editorState.scale * renderRatio;
                const finalX = editorState.offsetX * renderRatio;
                const finalY = editorState.offsetY * renderRatio;
                
                // 3. Desenhar com alta qualidade
                ctxFinal.drawImage(editorState.imgBitmap, finalX, finalY, 
                                   editorState.imgBitmap.width * finalScale, 
                                   editorState.imgBitmap.height * finalScale);

                // 4. Aplica Logo se selecionado no modal
                if (chkUseLogoModal.checked) {
                    await drawLogoOnCanvas(ctxFinal, finalCanvas.width, finalCanvas.height);
                }
                
                // 5. Comprimir novamente
                const result = await compressImage(finalCanvas, editorState.activeFile.name);
                
                // 6. Atualizar UI
                updateResultCard(editorState.activeCardId, result, editorState.activeFile);
                
                modal.close();
            } catch (err) {
                alert("Erro ao processar recorte: " + err.message);
            } finally {
                btnConfirmCrop.innerHTML = originalText;
            }
        };

    </script>
</body>
</html>
